---
title: Distributional Regression
author: Eric Dong & Patrick Laub
---

::: {.callout-warning}
This page is out of date for 2024, and will be updated shortly.
:::

```{python}
#| echo: false
#| warning: false
import os
os.environ["CUDA_VISIBLE_DEVICES"] = ""

import matplotlib

# TODO: Update following section
import matplotlib.pyplot as plt
import cycler

colors = ["#91CCCC", "#FF8FA9", "#CC91BC", "#3F9999", "#A5FFB8"]
plt.rcParams["axes.prop_cycle"] = cycler.cycler(color=colors)


def set_square_figures():
    plt.rcParams["figure.figsize"] = (2.0, 2.0)


def set_rectangular_figures():
    plt.rcParams["figure.figsize"] = (5.0, 2.0)


set_rectangular_figures()
plt.rcParams["figure.dpi"] = 350
plt.rcParams["savefig.bbox"] = "tight"
plt.rcParams["font.family"] = "serif"

plt.rcParams["axes.spines.right"] = False
plt.rcParams["axes.spines.top"] = False

import pandas as pandas

pandas.options.display.max_rows = 6

import random

random.seed(1234)

import tf_keras
import tensorflow

tensorflow.random.set_seed(1)
tensorflow.get_logger().setLevel("ERROR")
tensorflow.config.set_visible_devices([], "GPU")
```

::: {.content-visible unless-format="revealjs"}

```{python}
#| code-fold: true
#| code-summary: Show the package imports
import random
import matplotlib.pyplot as plt
import numpy as np
import numpy.random as rnd

from sklearn import set_config
set_config(transform_output="pandas")

import tf_keras
import tensorflow as tf
from tf_keras.callbacks import EarlyStopping
from tf_keras.layers import Dense
from tf_keras.models import Sequential
from tf_keras.layers import Input, Dense, Concatenate
from tf_keras.models import Model
from tf_keras.initializers import Constant

from sklearn.model_selection import train_test_split
from sklearn.compose import make_column_transformer
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OrdinalEncoder
```

:::

# Uncertainty & Distributional Regression {visibility="uncounted"}

::: {.content-visible unless-format="revealjs"}
Uncertainty in deep learning refers to the level of doubt one would have about the predictions made by an AI-driven algorithm. Identifying and quantifying different sources of uncertainty that could exist in AI-driven algorithms is therefore important to ensure a credible application.
:::

## Quiz

Question: *If you decide to predict the claim amount of Bob using a deep learning model, which source(s) of uncertainty are you confronting?*

1. The inherent variability of the data-generating process.
2. Parameter error.
3. Model error.
4. Data uncertainty.
5. All of the above.

## Answer

All of the above!

::: {.content-visible unless-format="revealjs"}
Parameter error stems primarily due to lack of data. Model error stems from assuming wrong distributional properties of the data. Data uncertainty arises due to the lack of confidence we may have about the quality of the collected data. Noisy data, inconsistent data, data with missing values or data with missing important variables can result in data uncertainty.
:::

There are two major types of uncertainty in statistical or machine learning:

- Aleatoric uncertainty
- Epistemic uncertainty

Since there is no consensus on the definitions of aleatoric and epistemic uncertainty, we provide the most acknowledged definitions in the following slides.

## Aleatoric Uncertainty

Qualitative Definition

:   *Aleatoric uncertainty refers to the statistical variability and inherent noise with data distribution that modelling cannot explain.*

Quantitative Definition

:   $$\text{Ale}(Y|\boldsymbol{x}) = \mathbb{V}[Y|\boldsymbol{x}],$$i.e., if $Y|\boldsymbol{x} \sim \mathcal{N}(\mu, \sigma^2)$, the aleatoric uncertainty would be $\sigma^2$. Simply, it is the conditional variance of the response variable $Y$ given features/covariates $\boldsymbol{x}$.

## Epistemic Uncertainty

Qualitative Definition

:   *Epistemic uncertainty refers to the lack of knowledge, limited data information, parameter errors and model errors.*

Quantitative Definition

:   $$\text{Epi}(Y|\boldsymbol{x}) = \text{Uncertainty}(Y|\boldsymbol{x}) - \text{Ale}(Y|\boldsymbol{x}),$$

i.e., the total uncertainty subtracting the aleatoric uncertainty $\mathbb{V}[Y|\boldsymbol{x}]$ would be the epistemic uncertainty.

## Uncertainty

Let's go back to the question at the beginning:

*If you decide to predict the claim amount of an individual using a deep learning model, which source(s) of uncertainty are you dealing with?*

1. The inherent variability of the data-generating process $\rightarrow$ aleatoric uncertainty.
2. Parameter error $\rightarrow$ epistemic uncertainty.
3. Model error $\rightarrow$ epistemic uncertainty.
4. Data uncertainty $\rightarrow$ epistemic uncertainty.


::: {.content-visible unless-format="revealjs"}
The following sections show how we prepare the datasets for studying uncertainty.
:::


## Code: Data

``` {python}
import pandas as pd
sev_df = pd.read_csv('freMTPL2sev.csv')                                 #<1>
freq_df = pd.read_csv('freMTPL2freq.csv')                               #<2>

# Create a copy of freq dataframe without 'claimfreq' column
freq_without_claimfreq = freq_df.drop(columns=['ClaimNb'])              #<3>

# Merge severity dataframe with freq_without_claimfreq dataframe
new_sev_df = pd.merge(sev_df, freq_without_claimfreq, on='IDpol', 
                                                      how='left')       #<4>
new_sev_df = new_sev_df.dropna()                                        #<5>
new_sev_df = new_sev_df.drop("IDpol", axis=1)                           #<6>
new_sev_df[:2]                                                          #<7>
```
1. Imports `freMTPL2sev.csv` dataset
2. Imports `freMTPL2freq.csv` dataset
3. Drops `ClaimNb` column
4. Merges the two datasets ,`sev_df` and `freq_without_claimfreq` by matching the `IDpol` column. Assigning `how='left'` ensures that all rows from the left dataset `sev_df` is considered, and only the matching columns from `freq_without_claimfreq` are selected
5. Drops missing values or/and NAN values
6. Drops the `IDpol` column from `new_sev_df`
7. Retrieves first two rows of the dataset

## Code: Preprocessing
::: {.content-visible unless-format="revealjs"}
Next we carry out some basic preprocessing
:::

```{python}
X_train, X_test, y_train, y_test = train_test_split(
  new_sev_df.drop("ClaimAmount", axis=1),
  new_sev_df["ClaimAmount"],
  random_state=2023)

# Reset each index to start at 0 again.
X_train = X_train.reset_index(drop=True)
X_test = X_test.reset_index(drop=True)
y_train = y_train.reset_index(drop=True)
y_test = y_test.reset_index(drop=True)
```

## Code: Preprocessing

::: {.content-visible unless-format="revealjs"}
Next we define the column transfer. The column transfer first applies ordinal encoding to `VehBrand`, `Region`, `Area` and `VehGas` variables, and applies standard scaling to all remaining numerical values. Next we fit the defined column transfer to the training set. The fitted transformation is then applied on both training and test sets. (Note that the fitting is only carried out on the train set and the same fit is applied to both train, validation and test sets.)
:::

::: {.content-visible unless-format="revealjs"}
Since this task does not apply entity embeddings, `VehBrand` and `Region` variables are dropped from the dataframe.
:::

```{python}
# Transformation
ct = make_column_transformer(
  (OrdinalEncoder(), ["VehBrand", "Region", "Area", "VehGas"]),
  remainder=StandardScaler(),
   verbose_feature_names_out=False
)

# We don't apply entity embedding 
X_train_ct = ct.fit_transform(X_train)
X_test_ct = ct.transform(X_test)
X_train = X_train_ct.drop(["VehBrand", "Region"], axis=1)
X_test = X_test_ct.drop(["VehBrand", "Region"], axis=1)
```

- $\texttt{VehGas=1}$ if the car gas is regular.
- $\texttt{Area=0}$ represents the rural area, and $\texttt{Area=5}$ represents the urban center.

## Histogram of the `ClaimAmount`

::: {.content-visible unless-format="revealjs"}
Plotting the empirical distribution of the target variable help us get an understanding of the inherent variability associated with the data.
:::

```{python}
plt.hist(y_train[y_train < 5000], bins=30);
```

<!--
# Aleatoric Uncertainty {visibility="uncounted"}

::: {.content-visible unless-format="revealjs"}
Aleatoric uncertainty refers to the inherent variability associated with the data generating process. Among many ways to capture the aleatoric uncertainty, (i) combining with probabilistic models and (ii) considering mixture models are two useful methods to quantify the inherent variability.
:::

-->
::: {.content-visible unless-format="revealjs"}
The following section illustrates how embedding a GLM in a neural network architecture can help us quantify the uncertainty relating to the predictions coming from the neural network. The idea is to first fit a GLM, and use the predictions from the GLM and predictions from the neural network part to define a custom loss function. This embedding presents an opportunity to compute the dispersion parameter $\phi_{CANN}$ for the neural network.
<!--The dispersion parameter provides insights into whether the model accurately captures the inherent variability (aleatoric uncertainty) in the data or not.-->
:::

# Generalised Linear Model (GLM) {visibility="uncounted"}

## GLM

The generalised linear model (GLM) is a statistical regression model that estimates the conditional mean of the response variable $Y$ given an instance $\boldsymbol{x}$ via a link function $g$:
$$
    \mathbb{E}[Y|\boldsymbol{x}]
    = \mu(\boldsymbol{x}; \boldsymbol{\beta}_{\text{GLM}})
    = g^{-1} \big(\big \langle \boldsymbol{\beta}_{\text{GLM}}, \boldsymbol{x} \big \rangle\big),
$$
where

- $\boldsymbol{x} \in \mathbb{R}^{d_{\boldsymbol{x}}}$ is the vector of explanatory variables, with $d_{\boldsymbol{x}}$ denoting its dimension.
- $\boldsymbol{\beta}_{\text{GLM}}$ represents the vector of regression coefficients.
- $\langle \boldsymbol{a}, \boldsymbol{b}\rangle$ represents the inner product of $\boldsymbol{a}$ and $\boldsymbol{b}$.

::: {.content-visible unless-format="revealjs"}
The idea of GLM is to find a linear combination of independent variables $\boldsymbol{x}$ and coefficients $\boldsymbol{\beta}$, apply a non-linear transformation ($g^{-1}$) to that linear combination and set it equal to conditional mean of the response variable $Y$ given an instance $\boldsymbol{x}$. The non-linear transformation provides added flexibility.
:::

## Gamma GLM

Suppose a fitted gamma GLM model has

- a log link function $g(x)=\log(x)$ and
- regression coefficients $\boldsymbol{\beta}_{\text{GLM}}=(\beta_0, \beta_1, \beta_2, \beta_3)$.

Then, it estimates the conditional mean of $Y$ given a new instance $\boldsymbol{x}=(1, x_1, x_2, x_3)$ as follows:
$$
    \mathbb{E}[Y|\boldsymbol{x}]=g^{-1}(\langle \boldsymbol{\beta}_{\text{GLM}}, \boldsymbol{x}\rangle)=\exp\big(\beta_0+ \beta_1x_1+\beta_2x_2+\beta_3x_3\big).
$$

A GLM can model any other exponential family distribution using an appropriate link function $g$.

## "Loss Function" for a Gamma GLM

If $Y|\boldsymbol{x}$ is a gamma r.v., we can parameterise its density by its mean $\mu(\boldsymbol{x}; \boldsymbol{\beta})$ and dispersion parameter $\phi$:
$$
    f_{Y|\boldsymbol{X}}(y|\boldsymbol{x}, \boldsymbol{\beta}, \phi)
    = \frac{(\mu (\boldsymbol{x}; \boldsymbol{\beta})\cdot \phi)^{-1/\phi}}{{\Gamma(1/\phi)}} \cdot y^{1/\phi - 1} \cdot \mathrm{e}^{-y/(\mu (\boldsymbol{x}; \boldsymbol{\beta})\cdot\phi)}.
$$
The "loss function" for a gamma GLM is typically the negative log-likelihood (NLL):
$$
    \sum_{i=1}^{N}-\log f_{Y|\boldsymbol{X}}(y_i|\boldsymbol{x}_i, \boldsymbol{\beta},\phi) 
    \propto \sum_{i=1}^{N}\log \mu (\boldsymbol{x}_i; \boldsymbol{\beta})+\frac{y_i}{\mu (\boldsymbol{x}_i; \boldsymbol{\beta})} + \text{const},
$$
i.e., we ignore the dispersion parameter $\phi$ while estimating the regression coefficients.


## Fitting Steps

Step 1. Use the advanced second derivative iterative method to find the regression coefficients:
$$
    \boldsymbol{\beta}_{\text{GLM}} = \underset{\boldsymbol{\beta}}{\text{arg min}} \ \sum_{i=1}^{N}\log \mu (\boldsymbol{x}_i; \boldsymbol{\beta})+\frac{y_i}{\mu (\boldsymbol{x}_i; \boldsymbol{\beta})}
$$

Step 2. Estimate the dispersion parameter:
$$
    \phi_{\text{GLM}}=\frac{1}{N-d_{\boldsymbol{x}}}\sum_{i=1}^{N}\frac{(y_i-\mu(\boldsymbol{x}_i; \boldsymbol{\beta}_{\text{GLM}} ))^2}{\mu(\boldsymbol{x}_i; \boldsymbol{\beta}_{\text{GLM}} )^2}
$$ 

## Code: Gamma GLM

In Python, we can fit a gamma GLM as follows:


```{python}
import statsmodels.api as sm

# Add a column of ones to include an intercept in the model
X_train_design = sm.add_constant(X_train)

# Create a Gamma GLM with a log link function
gamma_glm = sm.GLM(y_train, X_train_design,                   
            family=sm.families.Gamma(sm.families.links.Log()))

# Fit the model
gamma_glm = gamma_glm.fit()

# Dispersion Parameter
mus = gamma_glm.predict(X_train_design)
residuals = mus-y_train
variance = mus**2
dof = (len(y_train)-X_train.shape[1])
phi_glm =  np.sum(residuals**2/variance)/dof
print(phi_glm)
```

::: {.content-visible unless-format="revealjs"}
The above example of fitting a Gamma distribution assumes a constant dispersion, meaning that, the dispersion of claim amount is constant for all policyholders. If we believe that the constant dispersion assumption is quite strong, we can use a double GLM model. Fitting a GLM is the traditional way of modelling a claim amount.
:::

# Combined Actuarial Neural Network {visibility="uncounted"}

## CANN

The Combined Actuarial Neural Network is a novel actuarial neural network architecture proposed by Schelldorfer and WÃ¼thrich (2019). We summarise the CANN approach as follows:

- Find the coefficients $\boldsymbol{\beta}_{\text{GLM}}$ of the GLM with a link function $g(\cdot)$.
- Find the weights $\boldsymbol{w}_{\text{CANN}}$ of a neural network $\mathcal{M}_{\text{CANN}}:\mathbb{R}^{d_{\boldsymbol{x}}}\to\mathbb{R}$.
- Given a new instance $\boldsymbol{x}$, we have $$\mathbb{E}[Y|\boldsymbol{x}] = g^{-1}\Big( \langle\boldsymbol{\beta}_{\text{GLM}}, \boldsymbol{x}\rangle + \mathcal{M}_{\text{CANN}}(\boldsymbol{x};\boldsymbol{w}_{\text{CANN}})\Big).$$

## Architecture

![CANN approach.](CANN.png)

## Code: Architecture

```{python}
gamma_glm.params
```

```{python}
# Ensure reproducibility
random.seed(1); tf.random.set_seed(1)                                   #<1>

# Pre-defined constants
glm_weights = gamma_glm.params.iloc[1:]                                    #<2>
glm_bias = gamma_glm.params.iloc[0]                                        #<3>

# Define model inputs
inputs = Input(shape=X_train.shape[1:])                                 #<4>

# Non-trainable GLM linear part
glm_logmu = Dense(1, activation='linear', trainable=False,
                     kernel_initializer=Constant(glm_weights),
                     bias_initializer=Constant(glm_bias))(inputs)       #<5>         

# Neural network layers
x = Dense(64, activation='relu')(inputs)                                #<6>
x = Dense(64, activation='relu')(x)                                     #<7>
cann_logmu = Dense(1, activation='linear')(x)                           #<8>
```
1. Sets the random seed for reproducibility
2. Stores weights computed from GLM in `glm_weights`
3. Stores bias computed from GLM in `glm_bias`
4. Specifies the model input features
5. Adds a `Dense` layer with just one neuron, to store the model output from the GLM. The linear activation is used to make sure that the output is a linear combination of inputs. The weights are set to be non-trainable, hence the values obtained during GLM fitting will not change during the neural network training process. `kernel_initializer=Constant(glm_weights)` and `bias_initializer=Constant(glm_bias)` ensures that weights are initialized with the optimal values estimated from GLM fit. 
6. Adds another `Dense` layer 
7. Adds another `Dense` layer 
8. Adds the output layer with linear activation

## Code: Loss Function

```{python}
# Combine GLM and CANN estimates
cann = Model(inputs, Concatenate(axis=1)([cann_logmu, glm_logmu]))      #<1>
```
1. Since the output of the model is evaluated by combining the output from both branches, the model is constructed by concatenating outputs from `cann_logmu` and `glm_logmu`. Note that there are two predicted values, one predicted value from the `glm_logmu` component and the other coming from the `cann_logmu` component.

We need to customise the loss function for CANN.

```{python}
def cann_negative_log_likelihood(y_true, y_pred):
    #the new mean estimate
    cann_logmu = y_pred[:, 0]                                       #<1>
    glm_logmu = y_pred[:, 1]                                        #<2>
    mu = tf.math.exp(cann_logmu + glm_logmu)                        #<3>

    # Compute the negative log likelihood of the Gamma distribution
    nll = tf.reduce_mean(cann_logmu + glm_logmu + y_true/mu)        #<4>
    
    return nll
```
1. Stores the first column of the `y_pred` matrix as `cann_logmu` (the prediction from the CANN)
2. Stores the second column of the `y_pred` matrix as `glm_logmu` (the prediction from the glm)
3. Computes the exponential of the sum of them as `mu`
4. Computes the negative log likelihood of a Gamma distribution where $\log(\mu)$ is now the sum `cann_logmu + glm_logmu`

## Code: Model Training

```{python}
cann.compile(optimizer="adam", loss=cann_negative_log_likelihood)       #<1>
hist = cann.fit(X_train, y_train,
    epochs=100, 
    callbacks=[EarlyStopping(patience=10)],  
    verbose=0,
    batch_size=64, 
    validation_split=0.2)                                               #<2>
```
1. Compiles the model with adam optimizer and the custom loss function
2. Fits the model (with a validation split defined inside the fit function)

Find the dispersion parameter.

``` {python}
mus = np.exp(np.sum(cann.predict(X_train, verbose=0), axis = 1))
residuals = mus-y_train
variance = mus**2
dof = (len(y_train)-X_train.shape[1])
phi_cann =  np.sum(residuals**2/variance) / dof
print(phi_cann)
```

# Mixture Density Network {visibility="uncounted"}

## Mixture Distribution

::: {.content-visible unless-format="revealjs"}
One intuitive way to capture uncertainty using neural networks would be to estimate the parameters of the target distribution, instead of predicting the value it self. For example, suppose we want to predict $y$ coming from a Gaussian distribution. Most common method would be to predict $(\hat{y})$ directly using a single neuron at the output layer. Another possible way would be to estimate the parameters ($\mu$ and $\sigma$) of the $y$ distribution using 2 neurons at the output layer. Estimating parameters of the distribution instead of point estimates for $y$ can help us get an idea about the uncertainty. However, assuming distributional properties at times could be too restrictive. For example, it is possible that the actual distribution of $y$ values is bimodal or multi modal. In such situations, assuming a mixture distribution is more intuitive.    
:::

Given a finite set of resulting random variables $(Y_1, ..., Y_{K})$, one can generate a multinomial random variable $Y\sim \text{Multinomial}(1, \boldsymbol{\pi})$. Meanwhile, $Y$ can be regarded as a mixture of $Y_1, ..., Y_{K}$, i.e.,
$$
  Y = \begin{cases} 
      Y_1 & \text{w.p. } \pi_1, \\ 
      \vdots & \vdots\\
      Y_K & \text{w.p. } \pi_K, \\ 
  \end{cases}
$$
where we define a set of finite set of weights $\boldsymbol{\pi}=(\pi_{1} ..., \pi_{K})$ such that $\pi_k \ge 0$ for $k \in \{1, ..., K\}$ and $\sum_{k=1}^{K}\pi_k=1$.

## Mixture Distribution

Let $f_{Y_k|\boldsymbol{X}}$ and $F_{Y_k|\boldsymbol{X}}$ be the probability density function and the cumulative density function, respectively, of $Y_k|\boldsymbol{X}$ for all $k\in \{1, ..., K\}$. The random variable $Y|\boldsymbol{X}$, which mixes $Y_k|\boldsymbol{X}$'s with weights $\pi_k$'s, has the density function
$$
    f_{Y|\boldsymbol{X}}(y|\boldsymbol{x}) = \sum_{k=1}^{K}\pi_k(\boldsymbol{x}) f_{k}(y|\boldsymbol{x}),
$$
and the cumulative density function
$$
    F_{Y|\boldsymbol{X}}(y|\boldsymbol{x}) = \sum_{k=1}^{K}\pi_k(\boldsymbol{x}) F_{k}(y|\boldsymbol{x}).
$$

## Mixture Density Network

A mixture density network (MDN) $\mathcal{M}_{\boldsymbol{w}^*}$ outputs each distribution component's mixing weights and parameters of $Y$ given the input features $\boldsymbol{x}$, i.e.,
$$
    \mathcal{M}_{\boldsymbol{w}^*}(\boldsymbol{x})=(\boldsymbol{\pi}(\boldsymbol{x};\boldsymbol{w}^*), \boldsymbol{\theta}(\boldsymbol{x};\boldsymbol{w}^*)),
$$
where $\boldsymbol{w}^*$ is the networks' weights found by minimising the following negative log-likelihood loss function 
$$
    \mathcal{L}(\mathcal{D}, \boldsymbol{\theta})= - \sum_{i=1}^{N} \log f_{Y|\boldsymbol{x}}(y_i|\boldsymbol{x}, \boldsymbol{w}^*),
$$
where $\mathcal{D}=\{(\boldsymbol{x}_i,y_i)\}_{i=1}^{N}$ is the training dataset.

## Mixture Density Network

![An MDN that outputs the parameters for a $K$ component mixture distribution. $\boldsymbol{\theta}_k(\boldsymbol{x}; \boldsymbol{w}^*)= (\theta_{k,1}(\boldsymbol{x}; \boldsymbol{w}^*), ..., \theta_{k,|\boldsymbol{\theta}_k|}(\boldsymbol{x}; \boldsymbol{w}^*))$ consists of the parameter estimates for the $k$th mixture component.](MDN.png)

## Model Specification

Suppose there are two types of claims:

- Type I: $Y_1|\boldsymbol{x}\sim \text{Gamma}(\alpha_1(\boldsymbol{x}), \beta_1(\boldsymbol{x}))$ and,
- Type II: $Y_2|\boldsymbol{x}\sim \text{Gamma}(\alpha_2(\boldsymbol{x}), \beta_2(\boldsymbol{x}))$.

The density of the actual claim amount $Y|\boldsymbol{x}$ follows
$$
    \begin{align*}
        f_{Y|\boldsymbol{X}}(y|\boldsymbol{x})
        &= \pi_1(\boldsymbol{x})\cdot \frac{\beta_1(\boldsymbol{x})^{\alpha_1(\boldsymbol{x})}}{\Gamma(\alpha_1(\boldsymbol{x}))}\mathrm{e}^{-\beta_1(\boldsymbol{x})y}y^{\alpha_1(\boldsymbol{x})-1} \\
        &\quad + (1-\pi_1(\boldsymbol{x}))\cdot \frac{\beta_2(\boldsymbol{x})^{\alpha_2(\boldsymbol{x})}}{\Gamma(\alpha_2(\boldsymbol{x}))}\mathrm{e}^{-\beta_2(\boldsymbol{x})y}y^{\alpha_2(\boldsymbol{x})-1}.
    \end{align*}
$$
where $\pi_1(\boldsymbol{x})$ is the probability of a Type I claim given $\boldsymbol{x}$.

## Output

The aim is to find the optimum weights
$$
    \boldsymbol{w}^* = \underset{w}{\text{arg min}} \ \mathcal{L}(\mathcal{D}, \boldsymbol{w})
$$
for the Gamma mixture density network $\mathcal{M}_{\boldsymbol{w}^*}$ that outputs the mixing weights, shapes and scales of $Y$ given the input features $\boldsymbol{x}$, i.e.,
$$
    \begin{align*}
        \mathcal{M}_{\boldsymbol{w}^*}(\boldsymbol{x})
        = ( &\pi_1(\boldsymbol{x}; \boldsymbol{w}^*),
             \pi_2(\boldsymbol{x}; \boldsymbol{w}^*), \\
            &\alpha_1(\boldsymbol{x}; \boldsymbol{w}^*),
            \alpha_2(\boldsymbol{x}; \boldsymbol{w}^*),\\ 
            &\beta_1(\boldsymbol{x}; \boldsymbol{w}^*),
            \beta_2(\boldsymbol{x}; \boldsymbol{w}^*)
        ).
    \end{align*}
$$

## Architecture

![We demonstrate the structure of a gamma MDN that outputs the parameters for a gamma mixture with two components.](Gamma_MDN.png)

## Code: Architecture

The following code resembles the architecture of the architecture of the gamma MDN from the previous slide.

```{python}
# Ensure reproducibility
random.seed(1); tf.random.set_seed(1)                                   #<1>

inputs = Input(shape=X_train.shape[1:])                                 #<2>

# Two hidden layers 
x = Dense(64, activation='relu')(inputs)                                #<3>
x = Dense(64, activation='relu')(x)

pis = Dense(2, activation='softmax')(x) #mixing weights                 #<4>
alphas = Dense(2, activation='exponential')(x) #shape parameters
betas = Dense(2, activation='exponential')(x) #scale parameters

# `y_pred` will now have 6 columns
gamma_mdn = Model(inputs, Concatenate(axis=1)([pis, alphas, betas]))    #<5>
```
1. Sets the random seeds for reproducibility
2. Defines the input layer with the number of neurons being equal to the number of input features
3. Specifies the hidden layers of the neural network
4. Specifies the neurons of the output layer. Here, `softmax` is used for $\pi$ values as they must sum up to 1. `exponential` activation is used for both $\alpha$'s and $\beta$'s as they must be non-negative.
5. Defines the model by specifying the inputs and outputs


## Loss Function

The negative log-likelihood loss function is given by

$$
    \mathcal{L}(\mathcal{D}, \boldsymbol{w})
    = - \sum_{i=1}^{N} \log \  f_{Y|\boldsymbol{x}}(y_i|\boldsymbol{x}, \boldsymbol{w}) 
$$
where the $f_{Y|\boldsymbol{x}}(y_i|\boldsymbol{x}, \boldsymbol{w})$ is defined by
$$
\begin{align*}
    &\pi_1(\boldsymbol{x};\boldsymbol{w})\cdot \frac{\beta_1(\boldsymbol{x};\boldsymbol{w})^{\alpha_1(\boldsymbol{x};\boldsymbol{w})}}{\Gamma(\alpha_1(\boldsymbol{x};\boldsymbol{w}))}\mathrm{e}^{-\beta_1(\boldsymbol{x};\boldsymbol{w})y}y^{\alpha_1(\boldsymbol{x};\boldsymbol{w})-1} \\
    & \quad + (1-\pi_1(\boldsymbol{x};\boldsymbol{w}))\cdot \frac{\beta_2(\boldsymbol{x};\boldsymbol{w})^{\alpha_2(\boldsymbol{x};\boldsymbol{w})}}{\Gamma(\alpha_2(\boldsymbol{x};\boldsymbol{w}))}\mathrm{e}^{-\beta_2(\boldsymbol{x};\boldsymbol{w})y}y^{\alpha_2(\boldsymbol{x};\boldsymbol{w})-1} 
\end{align*}
$$

## Code: Loss Function

We employ functions from `tensorflow_probability` to code the loss function for the gamma MDN.
The `MixtureSameFamily` function facilitates defining a mixture distribution all components from the same distribution but have different parametrization.

```{python}
import tensorflow_probability as tfp                                        #<1>
tfd = tfp.distributions                                                     #<2>
K = 2 # number of mixture components                                        #<3>

def gamma_mixture_nll(y_true, y_pred):                                      
    K = y_pred.shape[1] // 3                                                #<4>
    pis =  y_pred[:, :K]                                                    
    alphas = y_pred[:, K:2*K]                                               
    betas = y_pred[:, 2*K:3*K]                                              

    # The mixture distribution is a MixtureSameFamily distribution
    mixture_distribution = tfd.MixtureSameFamily(
        mixture_distribution=tfd.Categorical(probs=pis),
        components_distribution=tfd.Gamma(alphas, betas))                   #<5>

    # The loss is the negative log-likelihood of the data
    return -mixture_distribution.log_prob(y_true)                           #<6>
```
1. Imports `tfp` class from `tensorflow_probability`
2. Stores statistical distributions in the `tfp` class as `tfd`
3. Specifies the number of components in the mixture model
4. Extracts predicted values for all model components and stores them in separate matrices
5. Specifies the mixture distribution using computed model components
6. Use the fitted model to calculate negative log likelihood given the observed data

## Code: Model Training

```{python}
# Employ the loss function from previous slide
gamma_mdn.compile(optimizer="adam", loss=gamma_mixture_nll)             #<1>

hist = gamma_mdn.fit(X_train, y_train,
    epochs=100, 
    callbacks=[EarlyStopping(patience=10)],  
    verbose=0,
    batch_size=64, 
    validation_split=0.2)                                               #<2>
```
1. Compiles the model using `adam` optimizer and the `gamma_mixture_nll` (negative log likelihood) as the loss function
2. Fits the model using the training data, with a validation split

# Metrics for Distributional Regression {visibility="uncounted"}

## Proper Scoring Rules

::: {.content-visible unless-format="revealjs"}
Proper scoring rules provide a summary measure for the performance of the probabilistic predictions. They are useful in comparing performances across models. 
:::

Definition

:   *The scoring rule* $S : \mathcal{F} \times \mathbb{R} \to \bar{\mathbb{R}}$ is proper relative to the class $\mathcal{F}$ if $$
    S(G, G)\le S(F, G)
    $$ for all $F,G\in \mathcal{F}$. It is strictly proper if equality holds only if $F = G$.

Examples:

- Logarithmic Score (NLL)
- Continuous Ranked Probability Score (CRPS)

## Proper Scoring Rules

Logarithmic Score (NLL)

:   The logarithmic score is defined as
    $$
        \mathrm{LogS}(f, y) = - \log f(y),
    $$
    where $f$ is the predictive density.

Continuous Ranked Probability Score (CRPS)

:   The continuous ranked probability score is defined as
    $$
        \mathrm{crps}(F, y) = \int_{-\infty}^{\infty} (F(t) - {1}_{t\ge y})^2 \ \mathrm{d}t,
    $$
    where $F$ is the cumulative distribution function.

## Code: NLL

```{python}
from scipy.stats import gamma

def gamma_nll(mean, dispersion, y):
    # Calculate shape and scale parameters from mean and dispersion
    shape = 1 / dispersion; scale = mean * dispersion

    # Create a gamma distribution object
    gamma_dist = gamma(a=shape, scale=scale)
    
    return -np.mean(gamma_dist.logpdf(y))

# GLM
X_test_design = sm.add_constant(X_test)
mus = gamma_glm.predict(X_test_design)
nll_glm = gamma_nll(mus, phi_glm, y_test)

# CANN
mus = np.exp(np.sum(cann.predict(X_test, verbose=0), axis = 1))
nll_cann = gamma_nll(mus, phi_cann, y_test)

# MDN
nll_mdn = gamma_mdn.evaluate(X_test, y_test, verbose=0)
```

## Model Comparisons

```{python}
print(f'GLM: {round(nll_glm, 2)}')
print(f'CANN: {round(nll_cann, 2)}')
print(f'MDN: {round(nll_mdn, 2)}')
```

::: {.content-visible unless-format="revealjs"}
The above results show that MDN provides the lowest value for the Logarithmic Score (NLL). Low values for NLL indicate better calibration. One possible reason for the better performance of the MDN model (compared to the Gamma model) is the added flexibility from multiple modelling components. The multiple modelling components in the MDN model, together, can capture the inherent variation in the data better.
:::


## Package Versions {.appendix data-visibility="uncounted"}

```{python}
from watermark import watermark
print(watermark(python=True, packages="keras,matplotlib,numpy,pandas,seaborn,scipy,torch,tensorflow,tensorflow_probability,tf_keras"))
```

## Glossary {.appendix data-visibility="uncounted"}

::: columns
::: column
- aleatoric and epistemic uncertainty
- deep ensembles
- CANN
- GLM
:::
::: column
- MDN
- mixture distribution
- posterior sampling
- proper scoring rule
:::
:::